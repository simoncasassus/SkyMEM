/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of GSLMIN.xs. Do not edit this file, edit GSLMIN.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "GSLMIN.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


#include <math.h>

#include "FUNC.c"
//extern void conjgrad(double*,int*, double* out);
typedef struct pdl_fr_meat_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Indx  __inc_xfree_n;PDL_Indx  __n_size;
		SV *funcion1;SV *funcion2;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_fr_meat_struct;

void pdl_fr_meat_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_fr_meat_struct *__privtrans = (pdl_fr_meat_struct *) __tr;
	
	{
	    PDL_Indx __creating[5];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xfree","stepsize","linmintol","gradtol","out"};
		static PDL_Indx __realdims[] = {1,0,0,0,0};
		static char __funcname[] = "GSLMIN::fr_meat";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in fr_meat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
PDL->make_physical(((__privtrans->pdls[1])));
PDL->make_physical(((__privtrans->pdls[2])));
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xfree_n = 0; else
		 __privtrans->__inc_xfree_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_fr_meat_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_fr_meat_struct *__privtrans = (pdl_fr_meat_struct *) __tr;
	
	{
	    pdl_fr_meat_struct *__copy = malloc(sizeof(pdl_fr_meat_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->funcion1) = newSVsv(__privtrans->funcion1);;(__copy->funcion2) = newSVsv(__privtrans->funcion2);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xfree_n=__copy->__inc_xfree_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_fr_meat_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_fr_meat_struct *__privtrans = (pdl_fr_meat_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Double * xfree_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xfree_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * stepsize_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * stepsize_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * linmintol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * linmintol_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * gradtol_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * gradtol_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * out_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * out_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	xfree_datap += __offsp[0];
	stepsize_datap += __offsp[1];
	linmintol_datap += __offsp[2];
	gradtol_datap += __offsp[3];
	out_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,xfree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,stepsize_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,linmintol_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,gradtol_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,out_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,xfree_datap += __tinc0_0
			,stepsize_datap += __tinc0_1
			,linmintol_datap += __tinc0_2
			,gradtol_datap += __tinc0_3
			,out_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_xfree_n = __privtrans->__inc_xfree_n;


int n; int i;
n = __privtrans->__n_size;
printf (" \n");
ene = __privtrans->__n_size;
ext_funname1 = __privtrans->funcion1;
ext_funname2 = __privtrans->funcion2;
conjgrad(xfree_datap, &n, out_datap, stepsize_datap, linmintol_datap,  gradtol_datap); 

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	xfree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	stepsize_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	linmintol_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	gradtol_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	out_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_fr_meat_free(pdl_trans *__tr ) {
	int __dim;
	pdl_fr_meat_struct *__privtrans = (pdl_fr_meat_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			SvREFCNT_dec(__privtrans->funcion1);;SvREFCNT_dec(__privtrans->funcion2);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_fr_meat_vtable_flags[] =
	 	{ 0,0,0,0,0};
	 pdl_transvtable pdl_fr_meat_vtable = {
		0,0, 4, 5, pdl_fr_meat_vtable_flags,
		pdl_fr_meat_redodims, pdl_fr_meat_readdata, NULL,
		pdl_fr_meat_free,NULL,NULL,pdl_fr_meat_copy,
		sizeof(pdl_fr_meat_struct),"pdl_fr_meat_vtable"
	 };



#line 1053 "GSLMIN.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 1197 "GSLMIN.c"

XS_EUPXS(XS_GSLMIN_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GSLMIN_set_debugging)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1051 "GSLMIN.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 1213 "GSLMIN.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GSLMIN_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GSLMIN_set_boundscheck)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1060 "GSLMIN.xs"
       if (! 1)
         warn("Bounds checking is disabled for GSLMIN");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 1236 "GSLMIN.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GSLMIN_fr_meat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GSLMIN_fr_meat)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1074 "GSLMIN.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *out_SV;
  pdl  *xfree;
  pdl  *out;
  pdl  *stepsize;
  pdl  *linmintol;
  pdl  *gradtol;
  SV *funcion1;
  SV *funcion2;
#line 1266 "GSLMIN.c"
#line 1088 "GSLMIN.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    xfree = PDL->SvPDLV(ST(0));
    out = PDL->SvPDLV(ST(1));
    stepsize = PDL->SvPDLV(ST(2));
    linmintol = PDL->SvPDLV(ST(3));
    gradtol = PDL->SvPDLV(ST(4));
    funcion1 = ST(5)
;
    funcion2 = ST(6)
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    xfree = PDL->SvPDLV(ST(0));
    stepsize = PDL->SvPDLV(ST(1));
    linmintol = PDL->SvPDLV(ST(2));
    gradtol = PDL->SvPDLV(ST(3));
    funcion1 = ST(4)
;
    funcion2 = ST(5)
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       out_SV = sv_newmortal();
       out = PDL->null();
       PDL->SetSV_PDL(out_SV,out);
       if (bless_stash) out_SV = sv_bless(out_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       out_SV = POPs;
       PUTBACK;
       out = PDL->SvPDLV(out_SV);
    }
  }
  else {
    croak ("Usage:  PDL::fr_meat(xfree,out,stepsize,linmintol,gradtol,funcion1,funcion2) (you may leave temporaries or output variables out of list)");
  }
}
{
	if ( out->state & PDL_INPLACE && (out != out)) {
              out->state &= ~PDL_INPLACE; PDL_COMMENT("unset")
              out = out;             PDL_COMMENT("discard output value, leak ?")
              PDL->SetSV_PDL(out_SV,out);
          }
}
 { pdl_fr_meat_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_fr_meat_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xfree->state & PDL_BADVAL) > 0) || ((stepsize->state & PDL_BADVAL) > 0) || ((linmintol->state & PDL_BADVAL) > 0) || ((gradtol->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != xfree->datatype) {
	     xfree = PDL->get_convertedpdl(xfree,PDL_D);
	  }if(PDL_D != stepsize->datatype) {
	     stepsize = PDL->get_convertedpdl(stepsize,PDL_D);
	  }if(PDL_D != linmintol->datatype) {
	     linmintol = PDL->get_convertedpdl(linmintol,PDL_D);
	  }if(PDL_D != gradtol->datatype) {
	     gradtol = PDL->get_convertedpdl(gradtol,PDL_D);
	  }if( (out->state & PDL_NOMYDIMS) && out->trans == NULL ) {
	     out->datatype = PDL_D;
	  } else if(PDL_D != out->datatype) {
	     out = PDL->get_convertedpdl(out,PDL_D);
	  }{(__privtrans->funcion1) = newSVsv(funcion1);(__privtrans->funcion2) = newSVsv(funcion2);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xfree;
__privtrans->pdls[1] = stepsize;
__privtrans->pdls[2] = linmintol;
__privtrans->pdls[3] = gradtol;
__privtrans->pdls[4] = out;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  out->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = out_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1378 "GSLMIN.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_GSLMIN); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_GSLMIN)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("GSLMIN::set_debugging", XS_GSLMIN_set_debugging, file, "$");
        (void)newXSproto_portable("GSLMIN::set_boundscheck", XS_GSLMIN_set_boundscheck, file, "$");
        (void)newXSproto_portable("GSLMIN::fr_meat", XS_GSLMIN_fr_meat, file, ";@");

    /* Initialisation Section */

#line 1201 "GSLMIN.xs"

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")

   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
#ifndef aTHX_
#define aTHX_
#endif
   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] GSLMIN needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 1435 "GSLMIN.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

