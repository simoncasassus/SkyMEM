/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of WCS.xs. Do not edit this file, edit WCS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "WCS.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif


	
#include <stdio.h>
#include <math.h>
#include <string.h>

typedef struct pdl_proj_meat_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Indx  __inc_ra_n;PDL_Indx  __inc_ra_m;PDL_Indx  __inc_dec_n;PDL_Indx  __inc_dec_m;PDL_Indx  __inc_x_n;PDL_Indx  __inc_x_m;PDL_Indx  __inc_y_n;PDL_Indx  __inc_y_m;PDL_Indx  __m_size;PDL_Indx  __n_size;
		int  direction;int  dohead;char *filename;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_proj_meat_struct;

void pdl_proj_meat_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_proj_meat_struct *__privtrans = (pdl_proj_meat_struct *) __tr;
	
	{
	    PDL_Indx __creating[4];
__privtrans->__m_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * ra_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * ra_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * dec_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * dec_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * x_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Short * ra_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * ra_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * dec_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * dec_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * x_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Ushort * ra_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * ra_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * dec_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * dec_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * ra_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ra_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dec_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dec_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * x_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Indx * ra_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Indx * ra_physdatap = ((PDL_Indx *)((__privtrans->pdls[0])->data));

	PDL_Indx * dec_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Indx * dec_physdatap = ((PDL_Indx *)((__privtrans->pdls[1])->data));

	PDL_Indx * x_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Indx * x_physdatap = ((PDL_Indx *)((__privtrans->pdls[2])->data));

	PDL_Indx * y_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Indx * y_physdatap = ((PDL_Indx *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_LongLong * ra_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * ra_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * dec_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * dec_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	PDL_LongLong * x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Float * ra_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * ra_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * dec_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * dec_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	PDL_Float * x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * x_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * ra_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ra_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dec_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dec_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ra","dec","x","y"};
		static PDL_Indx __realdims[] = {2,2,2,2};
		static char __funcname[] = "WCS::proj_meat";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__m_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__m_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__m_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__m_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in proj_meat:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));

{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")


         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_ra_n = 0; else
		 __privtrans->__inc_ra_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_ra_m = 0; else
		 __privtrans->__inc_ra_m = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_dec_n = 0; else
		 __privtrans->__inc_dec_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_dec_m = 0; else
		 __privtrans->__inc_dec_m = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_x_m = 0; else
		 __privtrans->__inc_x_m = __privtrans->pdls[2]->dimincs[1];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_y_m = 0; else
		 __privtrans->__inc_y_m = __privtrans->pdls[3]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_proj_meat_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_proj_meat_struct *__privtrans = (pdl_proj_meat_struct *) __tr;
	
	{
	    pdl_proj_meat_struct *__copy = malloc(sizeof(pdl_proj_meat_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->direction) = (__privtrans->direction);;(__copy->dohead) = (__privtrans->dohead);;(__copy->filename) = malloc(strlen(__privtrans->filename)+1); strcpy(__copy->filename,__privtrans->filename);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_ra_n=__copy->__inc_ra_n;__privtrans->__inc_ra_m=__copy->__inc_ra_m;__privtrans->__inc_dec_n=__copy->__inc_dec_n;__privtrans->__inc_dec_m=__copy->__inc_dec_m;__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_x_m=__copy->__inc_x_m;__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_y_m=__copy->__inc_y_m;__copy->__m_size=__privtrans->__m_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_proj_meat_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_proj_meat_struct *__privtrans = (pdl_proj_meat_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * ra_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * ra_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * dec_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * dec_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * x_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Short * ra_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * ra_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * dec_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * dec_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * x_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Ushort * ra_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * ra_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * dec_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * dec_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Long * ra_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * ra_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * dec_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * dec_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * x_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Indx * ra_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Indx * ra_physdatap = ((PDL_Indx *)((__privtrans->pdls[0])->data));

	PDL_Indx * dec_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Indx * dec_physdatap = ((PDL_Indx *)((__privtrans->pdls[1])->data));

	PDL_Indx * x_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Indx * x_physdatap = ((PDL_Indx *)((__privtrans->pdls[2])->data));

	PDL_Indx * y_datap = ((PDL_Indx *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Indx * y_physdatap = ((PDL_Indx *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_LongLong * ra_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * ra_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * dec_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * dec_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

	PDL_LongLong * x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Float * ra_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * ra_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * dec_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * dec_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

	PDL_Float * x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * x_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Double * ra_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ra_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * dec_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * dec_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	ra_datap += __offsp[0];
	dec_datap += __offsp[1];
	x_datap += __offsp[2];
	y_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,ra_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,dec_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,x_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,y_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,ra_datap += __tinc0_0
			,dec_datap += __tinc0_1
			,x_datap += __tinc0_2
			,y_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_y_n = __privtrans->__inc_y_n;
register PDL_Indx __inc_y_m = __privtrans->__inc_y_m;
register PDL_Indx __inc_x_n = __privtrans->__inc_x_n;
register PDL_Indx __inc_x_m = __privtrans->__inc_x_m;
register PDL_Indx __inc_dec_n = __privtrans->__inc_dec_n;
register PDL_Indx __inc_dec_m = __privtrans->__inc_dec_m;
register PDL_Indx __inc_ra_n = __privtrans->__inc_ra_n;
register PDL_Indx __inc_ra_m = __privtrans->__inc_ra_m;


        int nn, mm;
	nn = __privtrans->__n_size;
	mm = __privtrans->__m_size;
 	proj(__privtrans->direction,  __privtrans->filename, __privtrans->dohead, nn, mm, ra_datap, dec_datap, x_datap, y_datap);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	ra_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	dec_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	x_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	y_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_proj_meat_free(pdl_trans *__tr ) {
	int __dim;
	pdl_proj_meat_struct *__privtrans = (pdl_proj_meat_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			;;free(__privtrans->filename);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_proj_meat_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_proj_meat_vtable = {
		0,0, 4, 4, pdl_proj_meat_vtable_flags,
		pdl_proj_meat_redodims, pdl_proj_meat_readdata, NULL,
		pdl_proj_meat_free,NULL,NULL,pdl_proj_meat_copy,
		sizeof(pdl_proj_meat_struct),"pdl_proj_meat_vtable"
	 };



#line 1100 "WCS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 1244 "WCS.c"

XS_EUPXS(XS_WCS_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WCS_set_debugging)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1098 "WCS.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 1260 "WCS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_WCS_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WCS_set_boundscheck)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 1107 "WCS.xs"
       if (! 1)
         warn("Bounds checking is disabled for WCS");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 1283 "WCS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_WCS_proj_meat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_WCS_proj_meat)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1121 "WCS.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  pdl  *ra;
  pdl  *dec;
  pdl  *x;
  pdl  *y;
  int  direction;
  int  dohead;
  char *filename;
#line 1312 "WCS.c"
#line 1134 "WCS.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    ra = PDL->SvPDLV(ST(0));
    dec = PDL->SvPDLV(ST(1));
    x = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
    direction = (int)SvIV(ST(4))
;
    dohead = (int)SvIV(ST(5))
;
    filename = (char *)SvPV_nolen(ST(6))
;
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 0;
    ra = PDL->SvPDLV(ST(0));
    dec = PDL->SvPDLV(ST(1));
    x = PDL->SvPDLV(ST(2));
    y = PDL->SvPDLV(ST(3));
    direction = (int)SvIV(ST(4))
;
    dohead = (int)SvIV(ST(5))
;
    filename = (char *)SvPV_nolen(ST(6))
;
  }
  else {
    croak ("Usage:  PDL::proj_meat(ra,dec,x,y,direction,dohead,filename) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_proj_meat_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_proj_meat_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ra->state & PDL_BADVAL) > 0) || ((dec->state & PDL_BADVAL) > 0) || ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < ra->datatype) {
		 	__privtrans->__datatype = ra->datatype;
		    }
if(__privtrans->__datatype < dec->datatype) {
		 	__privtrans->__datatype = dec->datatype;
		    }
if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != ra->datatype) {
	     ra = PDL->get_convertedpdl(ra,__privtrans->__datatype);
	  }if(__privtrans->__datatype != dec->datatype) {
	     dec = PDL->get_convertedpdl(dec,__privtrans->__datatype);
	  }if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }{(__privtrans->direction) = (direction);(__privtrans->dohead) = (dohead);(__privtrans->filename) = malloc(strlen(filename)+1); strcpy(__privtrans->filename,filename);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ra;
__privtrans->pdls[1] = dec;
__privtrans->pdls[2] = x;
__privtrans->pdls[3] = y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 1412 "WCS.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_WCS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_WCS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("WCS::set_debugging", XS_WCS_set_debugging, file, "$");
        (void)newXSproto_portable("WCS::set_boundscheck", XS_WCS_set_boundscheck, file, "$");
        (void)newXSproto_portable("WCS::proj_meat", XS_WCS_proj_meat, file, ";@");

    /* Initialisation Section */

#line 1235 "WCS.xs"

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")

   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
#ifndef aTHX_
#define aTHX_
#endif
   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] WCS needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 1469 "WCS.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

